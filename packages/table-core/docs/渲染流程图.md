# 表格渲染流程图

## 1. 总体架构流程

```mermaid
graph TD
    A[表格初始化] --> B[创建DOM结构]
    B --> C[计算容器尺寸]
    C --> D[初始化虚拟滚动状态]
    D --> E[预计算行高（可选）]
    E --> F[首次渲染]
    
    F --> G{是否启用虚拟滚动?}
    G -->|是| H[计算可见行范围]
    G -->|否| I[全量渲染所有行]
    
    H --> J[渲染可见行+缓冲行]
    J --> K[设置行位置和高度]
    
    I --> K
    
    K --> L[绑定滚动事件]
    L --> M[渲染完成]
    
    M --> N{用户滚动?}
    N -->|是| O[滚动事件处理]
    N -->|否| P{数据变化?}
    
    O --> Q[批量更新机制]
    Q --> R[重新计算可见范围]
    R --> S[复用/创建行组件]
    S --> T[更新行位置]
    T --> K
    
    P -->|是| U[数据变化处理]
    P -->|否| M
    
    U --> V{变化类型}
    V -->|行数据变化| W[行刷新]
    V -->|单元格变化| X[单元格刷新]
    V -->|行高变化| Y[重新计算位置]
    
    W --> Z[RowCtrl.refreshRow]
    X --> AA[CellCtrl.refreshCell]
    Y --> AB[重新计算偏移量]
    
    Z --> K
    AA --> K
    AB --> K
```

## 2. 虚拟滚动详细流程

```mermaid
graph TD
    A[滚动事件触发] --> B[节流/防抖处理]
    B --> C[获取滚动位置 scrollTop]
    C --> D[计算起始行索引]
    
    D --> E[startIndex = floor(scrollTop / rowHeight) - overscan]
    E --> F[计算可见行数]
    F --> G[visibleCount = ceil(viewportHeight / rowHeight)]
    G --> H[计算结束索引]
    
    H --> I[endIndex = min(startIndex + visibleCount + 2*overscan, totalRows-1)]
    I --> J[获取当前渲染的行]
    J --> K{行是否已渲染?}
    
    K -->|是| L[复用现有行组件]
    K -->|否| M[创建新行组件]
    
    L --> N[更新行位置和样式]
    M --> O[创建RowCtrl]
    O --> P[创建RowComp]
    P --> Q[创建CellCtrl]
    Q --> R[创建CellComp]
    R --> N
    
    N --> S[应用transform偏移]
    S --> T[更新容器总高度]
    T --> U[渲染完成]
    
    U --> V{是否需要预计算校正?}
    V -->|是| W[测量实际行高]
    W --> X{估算误差>20%?}
    X -->|是| Y[更新高度模型]
    Y --> Z[重新计算所有位置]
    Z --> T
    X -->|否| U
    V -->|否| U
```

## 3. 行高度计算流程

```mermaid
graph TD
    A[需要计算行高] --> B{是否允许估算?}
    B -->|是| C{是否有getRowHeight函数?}
    B -->|否| D{是否有getRowHeight函数?}
    
    C -->|是| E[返回默认高度 + estimated=true]
    C -->|否| F[返回默认配置高度]
    
    D -->|是| G[调用getRowHeight函数]
    D -->|否| H[返回默认配置高度]
    
    G --> I[获取真实高度值]
    I --> J[返回 height + estimated=false]
    
    E --> K[存储估算标志]
    F --> L[完成计算]
    H --> L
    J --> L
    
    K --> M{行进入视口?}
    M -->|是| N[重新计算真实高度]
    N --> O[清除estimated标志]
    O --> P[更新行位置]
    P --> Q{引起其他行位置变化?}
    Q -->|是| R[级联更新相关行]
    Q -->|否| L
    M -->|否| L
    
    R --> S[重新计算偏移量缓存]
    S --> L
```

## 4. 预计算机制流程

```mermaid
graph TD
    A[启用预计算] --> B[数据加载完成]
    B --> C[智能采样]
    C --> D[均匀分布选择样本行]
    D --> E[创建隐藏预渲染容器]
    
    E --> F[预渲染采样行]
    F --> G[测量实际高度]
    G --> H[提取内容特征]
    
    H --> I[分析文本长度]
    I --> J[检测特殊字符]
    J --> K[检测换行符]
    K --> L[统计列配置]
    
    L --> M[构建高度模型]
    M --> N[计算基础高度]
    N --> O[分析变化因子]
    O --> P[生成估算算法]
    
    P --> Q[预计算完成]
    Q --> R[为所有行估算高度]
    R --> S[建立偏移量缓存]
    S --> T[开始正常渲染]
    
    T --> U{实际渲染时发现误差?}
    U -->|是| V[测量真实高度]
    V --> W{误差>阈值?}
    W -->|是| X[更新样本数据]
    X --> Y[重新训练模型]
    Y --> Z[更新所有估算]
    Z --> T
    W -->|否| T
    U -->|否| T
```

## 5. 数据变化时的DOM更新流程

```mermaid
graph TD
    A[数据发生变化] --> B{变化类型}
    
    B -->|整行数据变化| C[触发dataChanged事件]
    B -->|单个单元格变化| D[触发cellChanged事件]
    
    C --> E[RowCtrl.onRowNodeDataChanged]
    E --> F[调用refreshRow]
    
    F --> G{检查全宽行变化}
    G -->|有变化| H[完全重绘整行]
    G -->|无变化| I{检查是否为全宽行}
    
    I -->|是| J[刷新全宽行]
    I -->|否| K[遍历所有CellCtrl]
    
    J --> L{刷新成功?}
    L -->|否| H
    L -->|是| M[更新DOM属性]
    
    K --> N[调用cellCtrl.refreshCell]
    N --> O[检查值是否变化]
    
    O --> P{值有变化?}
    P -->|是| Q[调用showValue]
    P -->|否| R[跳过更新]
    
    Q --> S[comp.setRenderDetails]
    S --> T[实际更新DOM内容]
    
    M --> U[重新应用样式]
    T --> U
    R --> V[完成更新]
    U --> V
    H --> U
    
    D --> W[RowCtrl分发事件]
    W --> X[所有CellCtrl接收]
    X --> Y[检查是否影响本单元格]
    
    Y --> Z{列匹配?}
    Z -->|是| O
    Z -->|否| R
```

## 6. 性能优化机制

```mermaid
graph TD
    A[性能优化] --> B[批量更新机制]
    A --> C[行高缓存]
    A --> D[偏移量缓存]
    A --> E[Transform优化]
    
    B --> F[设置批处理阈值]
    F --> G[默认16ms]
    G --> H[收集滚动事件]
    H --> I[合并为单次更新]
    
    C --> J[创建行高缓存Map]
    J --> K[缓存函数计算结果]
    K --> L[限制缓存大小]
    L --> M[缓存命中率监控]
    
    D --> N[创建偏移量数组]
    N --> O[缓存每行偏移]
    O --> P[增量更新机制]
    P --> Q[减少重复计算]
    
    E --> R[使用transform替代padding]
    R --> S[避免触发重排]
    S --> T[只影响合成层]
    T --> U[显著减少重绘]
    
    I --> V[更新DOM]
    M --> V
    Q --> V
    U --> V
    
    V --> W[性能监控]
    W --> X[计算缓存命中率]
    X --> Y[统计计算次数]
    Y --> Z[测量平均计算时间]
    Z --> AA[提供优化建议]
```

## 7. 关键概念说明

### 7.1 三层渲染架构
- **RowRenderer**: 管理所有行的渲染逻辑，计算视口范围
- **RowCtrl**: 控制单个行的行为和状态
- **RowComp**: 负责实际的DOM渲染

### 7.2 虚拟滚动核心机制
- **可见范围计算**: 基于scrollTop和viewportHeight计算需要渲染的行范围
- **缓冲机制**: 在可见区域外额外渲染一些行，保证滚动平滑
- **组件复用**: 通过回收机制重用行组件，减少创建开销

### 7.3 行高计算策略
- **估算机制**: 初始时使用默认高度，标记为estimated
- **实际测量**: 行进入视口时重新计算真实高度
- **动态校正**: 根据实际渲染结果持续优化高度模型

### 7.4 性能优化技术
- **批量更新**: 合并多个滚动事件，减少重绘次数
- **缓存机制**: 缓存行高和偏移量计算结果
- **Transform优化**: 使用CSS transform避免触发重排

这个渲染流程图展示了表格从初始化到实际渲染的完整过程，包括虚拟滚动、行高计算、数据更新等核心机制，帮助理解整个系统的工作原理。