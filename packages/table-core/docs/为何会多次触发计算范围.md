让我分析一下 `calculateRange` 方法在滚动时执行多次的原因。从代码中可以看到几个关键点：

## 主要原因分析

### 1. 防抖机制设置
在 [`observeElementScroll`](packages/table-core/src/features/TableVirtual.ts:187) 函数中，使用了 [`debounce`](packages/table-core/src/features/TableVirtual.ts:187) 函数，但延迟时间设置为 **30ms**：

```typescript
const handler = debounce(
  window,
  () => {
    cb(
      {
        scrollLeft: element['scrollLeft'],
        scrollTop: element['scrollTop'],
      },
      false,
    )
  },
  30,  // 30ms 的防抖时间
)
```

### 2. 滚动事件触发链
滚动时会触发以下调用链：
1. 滚动事件 → [`observeElementScroll`](packages/table-core/src/features/TableVirtual.ts:201) 的 handler
2. handler 调用 [`table.setTableRender`](packages/table-core/src/features/TableVirtual.ts:527) 更新滚动状态
3. 然后调用 [`table.calculateRange()`](packages/table-core/src/features/TableVirtual.ts:532)

### 3. 元素大小变化触发
在 [`resizeItem`](packages/table-core/src/features/TableVirtual.ts:295) 函数中，当元素大小变化时也会调用 [`table.calculateRange()`](packages/table-core/src/features/TableVirtual.ts:295)：

```typescript
if (delta !== 0) {
  pendingMeasuredCacheIndexes.push(item.index)
  itemSizeCache = new Map(itemSizeCache.set(item.key, size))
  table.calculateRange()  // 这里也会触发
}
```

### 4. 依赖项变化触发
[`calculateRange`](packages/table-core/src/features/TableVirtual.ts:414) 方法使用了 memoization，依赖项包括：
- [`table.getMeasurements()`](packages/table-core/src/features/TableVirtual.ts:416) - 测量数据
- [`table.getViewportHeight()`](packages/table-core/src/features/TableVirtual.ts:417) - 视口高度
- [`table.getState().tableRender.scrollTop`](packages/table-core/src/features/TableVirtual.ts:418) - 滚动位置

当这些依赖项任何一个变化时，都会重新计算范围。

## 执行多次的具体原因

1. **防抖时间过短**：30ms 的防抖时间对于快速滚动来说太短，可能导致在滚动过程中多次触发

2. **状态更新分离**：滚动状态更新和范围计算是分开的两个操作，即使使用了防抖，也可能因为其他依赖项变化而触发多次计算

3. **元素测量变化**：在滚动过程中，如果元素大小发生变化（动态高度），会触发 [`resizeItem`](packages/table-core/src/features/TableVirtual.ts:270) 进而调用 [`calculateRange`](packages/table-core/src/features/TableVirtual.ts:295)

4. **memoization 依赖**：多个依赖项的变化都可能导致重新计算，而不仅仅是滚动位置

## 优化建议

1. 增加防抖时间到 100-150ms
2. 考虑将滚动状态更新和范围计算合并到一个防抖函数中
3. 优化依赖项，避免不必要的重新计算

经过分析，`calculateRange` 在滚动时执行多次的主要原因包括：

1. **防抖时间过短**：滚动事件使用了 30ms 的防抖时间，对于快速滚动来说时间太短，导致频繁触发。

2. **多重触发源**：
   - 滚动事件直接触发 `calculateRange()`
   - 元素大小变化时通过 `resizeItem()` 间接触发
   - 视口大小变化时也会触发

3. **状态更新链**：滚动时会先更新 `tableRender` 状态，然后单独调用 `calculateRange()`，这种分离的设计增加了触发次数。

4. **依赖项变化**：`calculateRange` 的 memoization 依赖多个状态（测量数据、视口高度、滚动位置），任何一个变化都会重新计算。

主要触发路径：
- 滚动事件 → `observeElementScroll` → `setTableRender` + `calculateRange`
- 元素大小变化 → `resizeItem` → `calculateRange`
- 视口大小变化 → `createViewportResizeObserver` → `calculateRange`

建议优化防抖时间到 100-150ms，并考虑合并相关状态更新操作。